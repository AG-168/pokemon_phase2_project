{"version":3,"file":"userfront-core.module.js","sources":["../src/store.js","../src/utils.js","../src/user.js","../src/api.js","../src/cookies.js","../src/tokens.js","../src/refresh.js","../src/session.js","../src/url.js","../src/password.js","../src/sso.js","../src/link.js","../src/verificationCode.js","../src/totp.js","../src/logout.js","../src/constants.js","../src/mode.js","../src/user.methods.js","../src/index.js","../src/login.js","../src/saml.js","../src/signup.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJwtPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\n/**\n * Client-side check:\n * Determine whether the given JWT is present and unexpired\n *\n * @param {String} token JSON Web Token\n * @returns {Boolean}\n */\nexport function isJwtLocallyValid(token) {\n  try {\n    // Must be present\n    if (!token) {\n      return false;\n    }\n\n    // Must not be expired\n    const payload = getJwtPayload(token);\n    return new Date(payload.exp * 1000) > new Date();\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJwtPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJwtPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\nimport { isJwtLocallyValid } from \"./utils.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Client-side check:\n * Determine whether the access token is present and unexpired\n * @returns {Boolean}\n */\nexport function isAccessTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.accessToken);\n}\n\n/**\n * Client-side check:\n * Determine whether the refresh token is present and unexpired\n * @returns {Boolean}\n */\nexport function isRefreshTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.refreshToken);\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import {\n  isAccessTokenLocallyValid,\n  isRefreshTokenLocallyValid,\n} from \"./tokens.js\";\nimport { refresh } from \"./refresh.js\";\n\n/**\n * Determine whether a user is logged in by checking their\n * JWT access token and, if invalid, refreshing it and checking\n * again.\n * @returns {Promise<Boolean>}\n */\nasync function getIsLoggedIn() {\n  try {\n    // If the access token is locally valid, return true\n    if (isAccessTokenLocallyValid()) {\n      return true;\n    }\n\n    // If the refresh token is locally invalid, return false\n    if (!isRefreshTokenLocallyValid()) {\n      return false;\n    }\n\n    // Attempt to refresh the access token\n    await refresh();\n\n    // The access token should now be valid\n    return isAccessTokenLocallyValid();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Return detailed information about the current session.\n * @returns {Promise<Object>}\n */\nexport async function getSession() {\n  const isLoggedIn = await getIsLoggedIn();\n  return { isLoggedIn };\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { getSession } from \"./session.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const handleRedirect = ({ redirect, data }) => {\n  if (redirect === false) return;\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's After-login path.\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  const { isLoggedIn } = await getSession();\n  if (!isLoggedIn) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * If the access token is invalid, redirect the browser to the\n * provided path.\n */\nexport async function redirectIfLoggedOut({ redirect } = {}) {\n  // If the user is logged in, return without doing anything\n  const { isLoggedIn } = await getSession();\n  if (isLoggedIn) {\n    return;\n  }\n\n  // Remove all cookies\n  removeAllCookies();\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no redirect path was provided, do not redirect\n  return;\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { exchange } from \"./refresh.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await post(`/auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await post(`/auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({ uuid, token, password, redirect });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({ uuid, token, password, redirect });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\"/auth/link\", {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(`/auth/code`, {\n      channel,\n      email,\n      phoneNumber,\n      name,\n      username,\n      data,\n      tenantId: store.tenantId,\n    });\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(`/auth/code`, {\n      channel,\n      verificationCode,\n      email,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    if (!totpCode && !backupCode) return;\n\n    const { data } = await post(`/auth/totp`, {\n      totpCode,\n      backupCode,\n      userId,\n      userUuid,\n      emailOrUsername,\n      email,\n      username,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { handleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    handleRedirect({ redirect, data });\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   handleRedirect({ redirect, data });\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJwtPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJwtPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { getSession } from \"./session\";\nimport { redirectIfLoggedIn, redirectIfLoggedOut } from \"./url.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // session\n  getSession,\n\n  // url\n  redirectIfLoggedIn,\n  redirectIfLoggedOut,\n\n  // user\n  user,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {Number} userId\n * @param {String} userUuid\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} phoneNumber\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} totpCode\n * @param {String} backupCode\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} verificationCode\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} phoneNumber\n * @param {String} name\n * @param {Object} data - Object for custom user fields\n * @param {String} password\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n"],"names":["store","user","tokens","mode","getJwtPayload","token","encodedPayload","split","replace","JSON","parse","atob","error","console","isJwtLocallyValid","payload","Date","exp","throwFormattedError","_error$response","_error$response$data","Error","response","data","message","reduceSlashes","str","put","path","options","url","baseUrl","Promise","resolve","axios","post","e","reject","get","setCookie","value","type","cookieName","tenantId","secure","sameSite","Cookies","set","removeCookie","name","paths","domains","window","location","pathname","hostname","primaryDomain","slice","join","undefined","err","map","domain","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","setCookiesAndTokens","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","then","exchange","_temp","_catch","basicRefresh","headers","authorization","status","warn","tokenName","idTokenPayload","propsToDefine","prop","setUser","isAccessTokenLocallyValid","getSession","getIsLoggedIn","isLoggedIn","getQueryAttr","attrName","href","indexOf","decodeURIComponent","handleRedirect","redirect","redirectToPath","redirectTo","pathOrUrl","document","el","createElement","assign","hash","search","updatePasswordWithJwt","password","existingPassword","Authorization","updatePasswordWithLink","uuid","updatePassword","method","resetPassword","signonWithSso","provider","origin","encodeURIComponent","getProviderLink","sendPasswordlessLink","email","username","userData","enforceChannel","channel","phoneNumber","sendVerificationCode","res","privateIPRegex","setMode","reason","getReason","setModeSync","modeValue","isTestHostname","hn","match","protocol","isHttps","update","Object","keys","length","hasRole","roleName","roles","getTotp","initCallbacks","isRegistered","index","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","_temp2","userUuid","completeSamlLogout","a","b","c","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","hasOwnProperty","_exit","loginWithPassword","_result2","loginWithLink","loginWithTotp","loginWithVerificationCode","_result3","completeSamlLogin","sendLoginLink","sendResetLink","signup","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath","redirectIfLoggedOut"],"mappings":"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"}